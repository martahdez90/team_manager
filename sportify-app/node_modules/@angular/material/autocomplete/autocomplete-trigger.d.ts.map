{"version":3,"file":"autocomplete-trigger.d.ts","sources":["autocomplete-trigger.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { BooleanInput } from '@angular/cdk/coercion';\r\nimport { Overlay, ScrollStrategy } from '@angular/cdk/overlay';\r\nimport { ViewportRuler } from '@angular/cdk/scrolling';\r\nimport { AfterViewInit, ChangeDetectorRef, ElementRef, InjectionToken, NgZone, OnDestroy, ViewContainerRef, OnChanges, SimpleChanges } from '@angular/core';\r\nimport { ControlValueAccessor } from '@angular/forms';\r\nimport { MatOption, MatOptionSelectionChange } from '@angular/material/core';\r\nimport { MatFormField } from '@angular/material/form-field';\r\nimport { Observable } from 'rxjs';\r\nimport { MatAutocomplete } from './autocomplete';\r\nimport { MatAutocompleteOrigin } from './autocomplete-origin';\r\n/**\r\n * The following style constants are necessary to save here in order\r\n * to properly calculate the scrollTop of the panel. Because we are not\r\n * actually focusing the active item, scroll must be handled manually.\r\n */\r\n/** The height of each autocomplete option. */\r\nexport declare const AUTOCOMPLETE_OPTION_HEIGHT = 48;\r\n/** The total height of the autocomplete panel. */\r\nexport declare const AUTOCOMPLETE_PANEL_HEIGHT = 256;\r\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\r\nexport declare const MAT_AUTOCOMPLETE_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\r\n/** @docs-private */\r\nexport declare function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;\r\n/** @docs-private */\r\nexport declare const MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER: {\r\n    provide: InjectionToken<() => ScrollStrategy>;\r\n    deps: (typeof Overlay)[];\r\n    useFactory: typeof MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY;\r\n};\r\n/**\r\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\r\n * @docs-private\r\n */\r\nexport declare const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any;\r\n/**\r\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\r\n * @docs-private\r\n */\r\nexport declare function getMatAutocompleteMissingPanelError(): Error;\r\nexport declare class MatAutocompleteTrigger implements ControlValueAccessor, AfterViewInit, OnChanges, OnDestroy {\r\n    private _element;\r\n    private _overlay;\r\n    private _viewContainerRef;\r\n    private _zone;\r\n    private _changeDetectorRef;\r\n    private _dir;\r\n    private _formField;\r\n    private _document;\r\n    private _viewportRuler;\r\n    private _overlayRef;\r\n    private _portal;\r\n    private _componentDestroyed;\r\n    private _autocompleteDisabled;\r\n    private _scrollStrategy;\r\n    /** Old value of the native input. Used to work around issues with the `input` event on IE. */\r\n    private _previousValue;\r\n    /** Strategy that is used to position the panel. */\r\n    private _positionStrategy;\r\n    /** Whether or not the label state is being overridden. */\r\n    private _manuallyFloatingLabel;\r\n    /** The subscription for closing actions (some are bound to document). */\r\n    private _closingActionsSubscription;\r\n    /** Subscription to viewport size changes. */\r\n    private _viewportSubscription;\r\n    /**\r\n     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\r\n     * closed autocomplete from being reopened if the user switches to another browser tab and then\r\n     * comes back.\r\n     */\r\n    private _canOpenOnNextFocus;\r\n    /** Whether the element is inside of a ShadowRoot component. */\r\n    private _isInsideShadowRoot;\r\n    /** Stream of keyboard events that can close the panel. */\r\n    private readonly _closeKeyEventStream;\r\n    /**\r\n     * Event handler for when the window is blurred. Needs to be an\r\n     * arrow function in order to preserve the context.\r\n     */\r\n    private _windowBlurHandler;\r\n    /** `View -> model callback called when value changes` */\r\n    _onChange: (value: any) => void;\r\n    /** `View -> model callback called when autocomplete has been touched` */\r\n    _onTouched: () => void;\r\n    /** The autocomplete panel to be attached to this trigger. */\r\n    autocomplete: MatAutocomplete;\r\n    /**\r\n     * Position of the autocomplete panel relative to the trigger element. A position of `auto`\r\n     * will render the panel underneath the trigger if there is enough space for it to fit in\r\n     * the viewport, otherwise the panel will be shown above it. If the position is set to\r\n     * `above` or `below`, the panel will always be shown above or below the trigger. no matter\r\n     * whether it fits completely in the viewport.\r\n     */\r\n    position: 'auto' | 'above' | 'below';\r\n    /**\r\n     * Reference relative to which to position the autocomplete panel.\r\n     * Defaults to the autocomplete trigger element.\r\n     */\r\n    connectedTo: MatAutocompleteOrigin;\r\n    /**\r\n     * `autocomplete` attribute to be set on the input element.\r\n     * @docs-private\r\n     */\r\n    autocompleteAttribute: string;\r\n    /**\r\n     * Whether the autocomplete is disabled. When disabled, the element will\r\n     * act as a regular input and the user won't be able to open the panel.\r\n     */\r\n    get autocompleteDisabled(): boolean;\r\n    set autocompleteDisabled(value: boolean);\r\n    constructor(_element: ElementRef<HTMLInputElement>, _overlay: Overlay, _viewContainerRef: ViewContainerRef, _zone: NgZone, _changeDetectorRef: ChangeDetectorRef, scrollStrategy: any, _dir: Directionality, _formField: MatFormField, _document: any, _viewportRuler: ViewportRuler);\r\n    ngAfterViewInit(): void;\r\n    ngOnChanges(changes: SimpleChanges): void;\r\n    ngOnDestroy(): void;\r\n    /** Whether or not the autocomplete panel is open. */\r\n    get panelOpen(): boolean;\r\n    private _overlayAttached;\r\n    /** Opens the autocomplete suggestion panel. */\r\n    openPanel(): void;\r\n    /** Closes the autocomplete suggestion panel. */\r\n    closePanel(): void;\r\n    /**\r\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\r\n     * within the viewport.\r\n     */\r\n    updatePosition(): void;\r\n    /**\r\n     * A stream of actions that should close the autocomplete panel, including\r\n     * when an option is selected, on blur, and when TAB is pressed.\r\n     */\r\n    get panelClosingActions(): Observable<MatOptionSelectionChange | null>;\r\n    /** Stream of autocomplete option selections. */\r\n    readonly optionSelections: Observable<MatOptionSelectionChange>;\r\n    /** The currently active option, coerced to MatOption type. */\r\n    get activeOption(): MatOption | null;\r\n    /** Stream of clicks outside of the autocomplete panel. */\r\n    private _getOutsideClickStream;\r\n    writeValue(value: any): void;\r\n    registerOnChange(fn: (value: any) => {}): void;\r\n    registerOnTouched(fn: () => {}): void;\r\n    setDisabledState(isDisabled: boolean): void;\r\n    _handleKeydown(event: KeyboardEvent): void;\r\n    _handleInput(event: KeyboardEvent): void;\r\n    _handleFocus(): void;\r\n    /**\r\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\r\n     * This causes the value to jump when selecting an option with the mouse.\r\n     * This method manually floats the label until the panel can be closed.\r\n     * @param shouldAnimate Whether the label should be animated when it is floated.\r\n     */\r\n    private _floatLabel;\r\n    /** If the label has been manually elevated, return it to its normal state. */\r\n    private _resetLabel;\r\n    /**\r\n     * Given that we are not actually focusing active options, we must manually adjust scroll\r\n     * to reveal options below the fold. First, we find the offset of the option from the top\r\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\r\n     * the panel height + the option height, so the active option will be just visible at the\r\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\r\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\r\n     * not adjusted.\r\n     */\r\n    private _scrollToOption;\r\n    /**\r\n     * This method listens to a stream of panel closing actions and resets the\r\n     * stream every time the option list changes.\r\n     */\r\n    private _subscribeToClosingActions;\r\n    /** Destroys the autocomplete suggestion panel. */\r\n    private _destroyPanel;\r\n    private _setTriggerValue;\r\n    /**\r\n     * This method closes the panel, and if a value is specified, also sets the associated\r\n     * control to that value. It will also mark the control as dirty if this interaction\r\n     * stemmed from the user.\r\n     */\r\n    private _setValueAndClose;\r\n    /**\r\n     * Clear any previous selected option and emit a selection change event for this option\r\n     */\r\n    private _clearPreviousSelectedOption;\r\n    private _attachOverlay;\r\n    private _getOverlayConfig;\r\n    private _getOverlayPosition;\r\n    /** Sets the positions on a position strategy based on the directive's input state. */\r\n    private _setStrategyPositions;\r\n    private _getConnectedElement;\r\n    private _getPanelWidth;\r\n    /** Returns the width of the input element, so the panel width can match it. */\r\n    private _getHostWidth;\r\n    /**\r\n     * Resets the active item to -1 so arrow events will activate the\r\n     * correct options, or to 0 if the consumer opted into it.\r\n     */\r\n    private _resetActiveItem;\r\n    /** Determines whether the panel can be opened. */\r\n    private _canOpen;\r\n    /** Use defaultView of injected document if available or fallback to global window reference */\r\n    private _getWindow;\r\n    static ngAcceptInputType_autocompleteDisabled: BooleanInput;\r\n}\r\n"]}
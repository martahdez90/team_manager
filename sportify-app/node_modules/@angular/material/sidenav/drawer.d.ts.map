{"version":3,"file":"drawer.d.ts","sources":["drawer.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { AnimationEvent } from '@angular/animations';\r\nimport { FocusMonitor, FocusOrigin, FocusTrapFactory } from '@angular/cdk/a11y';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { BooleanInput } from '@angular/cdk/coercion';\r\nimport { Platform } from '@angular/cdk/platform';\r\nimport { CdkScrollable, ScrollDispatcher, ViewportRuler } from '@angular/cdk/scrolling';\r\nimport { AfterContentChecked, AfterContentInit, ChangeDetectorRef, DoCheck, ElementRef, EventEmitter, InjectionToken, NgZone, OnDestroy, QueryList } from '@angular/core';\r\nimport { Observable, Subject } from 'rxjs';\r\n/**\r\n * Throws an exception when two MatDrawer are matching the same position.\r\n * @docs-private\r\n */\r\nexport declare function throwMatDuplicatedDrawerError(position: string): void;\r\n/** Result of the toggle promise that indicates the state of the drawer. */\r\nexport declare type MatDrawerToggleResult = 'open' | 'close';\r\n/** Drawer and SideNav display modes. */\r\nexport declare type MatDrawerMode = 'over' | 'push' | 'side';\r\n/** Configures whether drawers should use auto sizing by default. */\r\nexport declare const MAT_DRAWER_DEFAULT_AUTOSIZE: InjectionToken<boolean>;\r\n/**\r\n * Used to provide a drawer container to a drawer while avoiding circular references.\r\n * @docs-private\r\n */\r\nexport declare const MAT_DRAWER_CONTAINER: InjectionToken<unknown>;\r\n/** @docs-private */\r\nexport declare function MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY(): boolean;\r\nexport declare class MatDrawerContent extends CdkScrollable implements AfterContentInit {\r\n    private _changeDetectorRef;\r\n    _container: MatDrawerContainer;\r\n    constructor(_changeDetectorRef: ChangeDetectorRef, _container: MatDrawerContainer, elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, ngZone: NgZone);\r\n    ngAfterContentInit(): void;\r\n}\r\n/**\r\n * This component corresponds to a drawer that can be opened on the drawer container.\r\n */\r\nexport declare class MatDrawer implements AfterContentInit, AfterContentChecked, OnDestroy {\r\n    private _elementRef;\r\n    private _focusTrapFactory;\r\n    private _focusMonitor;\r\n    private _platform;\r\n    private _ngZone;\r\n    private _doc;\r\n    /**\r\n     * @deprecated `_container` parameter to be made required.\r\n     * @breaking-change 10.0.0\r\n     */\r\n    _container?: MatDrawerContainer | undefined;\r\n    private _focusTrap;\r\n    private _elementFocusedBeforeDrawerWasOpened;\r\n    /** Whether the drawer is initialized. Used for disabling the initial animation. */\r\n    private _enableAnimations;\r\n    /** The side that the drawer is attached to. */\r\n    get position(): 'start' | 'end';\r\n    set position(value: 'start' | 'end');\r\n    private _position;\r\n    /** Mode of the drawer; one of 'over', 'push' or 'side'. */\r\n    get mode(): MatDrawerMode;\r\n    set mode(value: MatDrawerMode);\r\n    private _mode;\r\n    /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\r\n    get disableClose(): boolean;\r\n    set disableClose(value: boolean);\r\n    private _disableClose;\r\n    /**\r\n     * Whether the drawer should focus the first focusable element automatically when opened.\r\n     * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly\r\n     * enabled, focus will be moved into the sidenav in `side` mode as well.\r\n     */\r\n    get autoFocus(): boolean;\r\n    set autoFocus(value: boolean);\r\n    private _autoFocus;\r\n    /**\r\n     * Whether the drawer is opened. We overload this because we trigger an event when it\r\n     * starts or end.\r\n     */\r\n    get opened(): boolean;\r\n    set opened(value: boolean);\r\n    private _opened;\r\n    /** How the sidenav was opened (keypress, mouse click etc.) */\r\n    private _openedVia;\r\n    /** Emits whenever the drawer has started animating. */\r\n    _animationStarted: Subject<AnimationEvent>;\r\n    /** Emits whenever the drawer is done animating. */\r\n    _animationEnd: Subject<AnimationEvent>;\r\n    /** Current state of the sidenav animation. */\r\n    _animationState: 'open-instant' | 'open' | 'void';\r\n    /** Event emitted when the drawer open state is changed. */\r\n    readonly openedChange: EventEmitter<boolean>;\r\n    /** Event emitted when the drawer has been opened. */\r\n    get _openedStream(): Observable<void>;\r\n    /** Event emitted when the drawer has started opening. */\r\n    get openedStart(): Observable<void>;\r\n    /** Event emitted when the drawer has been closed. */\r\n    get _closedStream(): Observable<void>;\r\n    /** Event emitted when the drawer has started closing. */\r\n    get closedStart(): Observable<void>;\r\n    /** Emits when the component is destroyed. */\r\n    private readonly _destroyed;\r\n    /** Event emitted when the drawer's position changes. */\r\n    onPositionChanged: EventEmitter<void>;\r\n    /**\r\n     * An observable that emits when the drawer mode changes. This is used by the drawer container to\r\n     * to know when to when the mode changes so it can adapt the margins on the content.\r\n     */\r\n    readonly _modeChanged: Subject<void>;\r\n    constructor(_elementRef: ElementRef<HTMLElement>, _focusTrapFactory: FocusTrapFactory, _focusMonitor: FocusMonitor, _platform: Platform, _ngZone: NgZone, _doc: any, \r\n    /**\r\n     * @deprecated `_container` parameter to be made required.\r\n     * @breaking-change 10.0.0\r\n     */\r\n    _container?: MatDrawerContainer | undefined);\r\n    /**\r\n     * Moves focus into the drawer. Note that this works even if\r\n     * the focus trap is disabled in `side` mode.\r\n     */\r\n    private _takeFocus;\r\n    /**\r\n     * Restores focus to the element that was originally focused when the drawer opened.\r\n     * If no element was focused at that time, the focus will be restored to the drawer.\r\n     */\r\n    private _restoreFocus;\r\n    /** Whether focus is currently within the drawer. */\r\n    private _isFocusWithinDrawer;\r\n    ngAfterContentInit(): void;\r\n    ngAfterContentChecked(): void;\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * Open the drawer.\r\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n     * Used for focus management after the sidenav is closed.\r\n     */\r\n    open(openedVia?: FocusOrigin): Promise<MatDrawerToggleResult>;\r\n    /** Close the drawer. */\r\n    close(): Promise<MatDrawerToggleResult>;\r\n    /** Closes the drawer with context that the backdrop was clicked. */\r\n    _closeViaBackdropClick(): Promise<MatDrawerToggleResult>;\r\n    /**\r\n     * Toggle this drawer.\r\n     * @param isOpen Whether the drawer should be open.\r\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n     * Used for focus management after the sidenav is closed.\r\n     */\r\n    toggle(isOpen?: boolean, openedVia?: FocusOrigin): Promise<MatDrawerToggleResult>;\r\n    /**\r\n     * Toggles the opened state of the drawer.\r\n     * @param isOpen Whether the drawer should open or close.\r\n     * @param restoreFocus Whether focus should be restored on close.\r\n     * @param openedVia Focus origin that can be optionally set when opening a drawer. The\r\n     *   origin will be used later when focus is restored on drawer close.\r\n     */\r\n    private _setOpen;\r\n    get _width(): number;\r\n    /** Updates the enabled state of the focus trap. */\r\n    private _updateFocusTrapState;\r\n    _animationStartListener(event: AnimationEvent): void;\r\n    _animationDoneListener(event: AnimationEvent): void;\r\n    static ngAcceptInputType_disableClose: BooleanInput;\r\n    static ngAcceptInputType_autoFocus: BooleanInput;\r\n    static ngAcceptInputType_opened: BooleanInput;\r\n}\r\n/**\r\n * `<mat-drawer-container>` component.\r\n *\r\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\r\n * and coordinates the backdrop and content styling.\r\n */\r\nexport declare class MatDrawerContainer implements AfterContentInit, DoCheck, OnDestroy {\r\n    private _dir;\r\n    private _element;\r\n    private _ngZone;\r\n    private _changeDetectorRef;\r\n    private _animationMode?;\r\n    /** All drawers in the container. Includes drawers from inside nested containers. */\r\n    _allDrawers: QueryList<MatDrawer>;\r\n    /** Drawers that belong to this container. */\r\n    _drawers: QueryList<MatDrawer>;\r\n    _content: MatDrawerContent;\r\n    _userContent: MatDrawerContent;\r\n    /** The drawer child with the `start` position. */\r\n    get start(): MatDrawer | null;\r\n    /** The drawer child with the `end` position. */\r\n    get end(): MatDrawer | null;\r\n    /**\r\n     * Whether to automatically resize the container whenever\r\n     * the size of any of its drawers changes.\r\n     *\r\n     * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\r\n     * the drawers on every change detection cycle. Can be configured globally via the\r\n     * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\r\n     */\r\n    get autosize(): boolean;\r\n    set autosize(value: boolean);\r\n    private _autosize;\r\n    /**\r\n     * Whether the drawer container should have a backdrop while one of the sidenavs is open.\r\n     * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\r\n     * mode as well.\r\n     */\r\n    get hasBackdrop(): any;\r\n    set hasBackdrop(value: any);\r\n    _backdropOverride: boolean | null;\r\n    /** Event emitted when the drawer backdrop is clicked. */\r\n    readonly backdropClick: EventEmitter<void>;\r\n    /** The drawer at the start/end position, independent of direction. */\r\n    private _start;\r\n    private _end;\r\n    /**\r\n     * The drawer at the left/right. When direction changes, these will change as well.\r\n     * They're used as aliases for the above to set the left/right style properly.\r\n     * In LTR, _left == _start and _right == _end.\r\n     * In RTL, _left == _end and _right == _start.\r\n     */\r\n    private _left;\r\n    private _right;\r\n    /** Emits when the component is destroyed. */\r\n    private readonly _destroyed;\r\n    /** Emits on every ngDoCheck. Used for debouncing reflows. */\r\n    private readonly _doCheckSubject;\r\n    /**\r\n     * Margins to be applied to the content. These are used to push / shrink the drawer content when a\r\n     * drawer is open. We use margin rather than transform even for push mode because transform breaks\r\n     * fixed position elements inside of the transformed element.\r\n     */\r\n    _contentMargins: {\r\n        left: number | null;\r\n        right: number | null;\r\n    };\r\n    readonly _contentMarginChanges: Subject<{\r\n        left: number | null;\r\n        right: number | null;\r\n    }>;\r\n    /** Reference to the CdkScrollable instance that wraps the scrollable content. */\r\n    get scrollable(): CdkScrollable;\r\n    constructor(_dir: Directionality, _element: ElementRef<HTMLElement>, _ngZone: NgZone, _changeDetectorRef: ChangeDetectorRef, viewportRuler: ViewportRuler, defaultAutosize?: boolean, _animationMode?: string | undefined);\r\n    ngAfterContentInit(): void;\r\n    ngOnDestroy(): void;\r\n    /** Calls `open` of both start and end drawers */\r\n    open(): void;\r\n    /** Calls `close` of both start and end drawers */\r\n    close(): void;\r\n    /**\r\n     * Recalculates and updates the inline styles for the content. Note that this should be used\r\n     * sparingly, because it causes a reflow.\r\n     */\r\n    updateContentMargins(): void;\r\n    ngDoCheck(): void;\r\n    /**\r\n     * Subscribes to drawer events in order to set a class on the main container element when the\r\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\r\n     * is properly hidden.\r\n     */\r\n    private _watchDrawerToggle;\r\n    /**\r\n     * Subscribes to drawer onPositionChanged event in order to\r\n     * re-validate drawers when the position changes.\r\n     */\r\n    private _watchDrawerPosition;\r\n    /** Subscribes to changes in drawer mode so we can run change detection. */\r\n    private _watchDrawerMode;\r\n    /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\r\n    private _setContainerClass;\r\n    /** Validate the state of the drawer children components. */\r\n    private _validateDrawers;\r\n    /** Whether the container is being pushed to the side by one of the drawers. */\r\n    private _isPushed;\r\n    _onBackdropClicked(): void;\r\n    _closeModalDrawersViaBackdrop(): void;\r\n    _isShowingBackdrop(): boolean;\r\n    private _canHaveBackdrop;\r\n    private _isDrawerOpen;\r\n    static ngAcceptInputType_autosize: BooleanInput;\r\n    static ngAcceptInputType_hasBackdrop: BooleanInput;\r\n}\r\n"]}
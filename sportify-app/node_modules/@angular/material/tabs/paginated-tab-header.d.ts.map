{"version":3,"file":"paginated-tab-header.d.ts","sources":["paginated-tab-header.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { ChangeDetectorRef, ElementRef, NgZone, QueryList, EventEmitter, AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy } from '@angular/core';\r\nimport { Direction, Directionality } from '@angular/cdk/bidi';\r\nimport { NumberInput } from '@angular/cdk/coercion';\r\nimport { ViewportRuler } from '@angular/cdk/scrolling';\r\nimport { FocusableOption } from '@angular/cdk/a11y';\r\nimport { Subject } from 'rxjs';\r\nimport { Platform } from '@angular/cdk/platform';\r\n/**\r\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\r\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\r\n * beginning of the list.\r\n */\r\nexport declare type ScrollDirection = 'after' | 'before';\r\n/** Item inside a paginated tab header. */\r\nexport declare type MatPaginatedTabHeaderItem = FocusableOption & {\r\n    elementRef: ElementRef;\r\n};\r\n/**\r\n * Base class for a tab header that supported pagination.\r\n * @docs-private\r\n */\r\nexport declare abstract class MatPaginatedTabHeader implements AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy {\r\n    protected _elementRef: ElementRef<HTMLElement>;\r\n    protected _changeDetectorRef: ChangeDetectorRef;\r\n    private _viewportRuler;\r\n    private _dir;\r\n    private _ngZone;\r\n    /**\r\n     * @deprecated @breaking-change 9.0.0 `_platform` and `_animationMode`\r\n     * parameters to become required.\r\n     */\r\n    private _platform?;\r\n    _animationMode?: string | undefined;\r\n    abstract _items: QueryList<MatPaginatedTabHeaderItem>;\r\n    abstract _inkBar: {\r\n        hide: () => void;\r\n        alignToElement: (element: HTMLElement) => void;\r\n    };\r\n    abstract _tabListContainer: ElementRef<HTMLElement>;\r\n    abstract _tabList: ElementRef<HTMLElement>;\r\n    abstract _nextPaginator: ElementRef<HTMLElement>;\r\n    abstract _previousPaginator: ElementRef<HTMLElement>;\r\n    /** The distance in pixels that the tab labels should be translated to the left. */\r\n    private _scrollDistance;\r\n    /** Whether the header should scroll to the selected index after the view has been checked. */\r\n    private _selectedIndexChanged;\r\n    /** Emits when the component is destroyed. */\r\n    protected readonly _destroyed: Subject<void>;\r\n    /** Whether the controls for pagination should be displayed */\r\n    _showPaginationControls: boolean;\r\n    /** Whether the tab list can be scrolled more towards the end of the tab label list. */\r\n    _disableScrollAfter: boolean;\r\n    /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\r\n    _disableScrollBefore: boolean;\r\n    /**\r\n     * The number of tab labels that are displayed on the header. When this changes, the header\r\n     * should re-evaluate the scroll position.\r\n     */\r\n    private _tabLabelCount;\r\n    /** Whether the scroll distance has changed and should be applied after the view is checked. */\r\n    private _scrollDistanceChanged;\r\n    /** Used to manage focus between the tabs. */\r\n    private _keyManager;\r\n    /** Cached text content of the header. */\r\n    private _currentTextContent;\r\n    /** Stream that will stop the automated scrolling. */\r\n    private _stopScrolling;\r\n    /**\r\n     * Whether pagination should be disabled. This can be used to avoid unnecessary\r\n     * layout recalculations if it's known that pagination won't be required.\r\n     */\r\n    disablePagination: boolean;\r\n    /** The index of the active tab. */\r\n    get selectedIndex(): number;\r\n    set selectedIndex(value: number);\r\n    private _selectedIndex;\r\n    /** Event emitted when the option is selected. */\r\n    readonly selectFocusedIndex: EventEmitter<number>;\r\n    /** Event emitted when a label is focused. */\r\n    readonly indexFocused: EventEmitter<number>;\r\n    constructor(_elementRef: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, _viewportRuler: ViewportRuler, _dir: Directionality, _ngZone: NgZone, \r\n    /**\r\n     * @deprecated @breaking-change 9.0.0 `_platform` and `_animationMode`\r\n     * parameters to become required.\r\n     */\r\n    _platform?: Platform | undefined, _animationMode?: string | undefined);\r\n    /** Called when the user has selected an item via the keyboard. */\r\n    protected abstract _itemSelected(event: KeyboardEvent): void;\r\n    ngAfterViewInit(): void;\r\n    ngAfterContentInit(): void;\r\n    ngAfterContentChecked(): void;\r\n    ngOnDestroy(): void;\r\n    /** Handles keyboard events on the header. */\r\n    _handleKeydown(event: KeyboardEvent): void;\r\n    /**\r\n     * Callback for when the MutationObserver detects that the content has changed.\r\n     */\r\n    _onContentChanges(): void;\r\n    /**\r\n     * Updates the view whether pagination should be enabled or not.\r\n     *\r\n     * WARNING: Calling this method can be very costly in terms of performance. It should be called\r\n     * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\r\n     * page.\r\n     */\r\n    updatePagination(): void;\r\n    /** Tracks which element has focus; used for keyboard navigation */\r\n    get focusIndex(): number;\r\n    /** When the focus index is set, we must manually send focus to the correct label */\r\n    set focusIndex(value: number);\r\n    /**\r\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\r\n     * providing a valid index and return true.\r\n     */\r\n    _isValidIndex(index: number): boolean;\r\n    /**\r\n     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\r\n     * scrolling is enabled.\r\n     */\r\n    _setTabFocus(tabIndex: number): void;\r\n    /** The layout direction of the containing app. */\r\n    _getLayoutDirection(): Direction;\r\n    /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\r\n    _updateTabScrollPosition(): void;\r\n    /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\r\n    get scrollDistance(): number;\r\n    set scrollDistance(value: number);\r\n    /**\r\n     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\r\n     * the end of the list, respectively). The distance to scroll is computed to be a third of the\r\n     * length of the tab list view window.\r\n     *\r\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\r\n     * should be called sparingly.\r\n     */\r\n    _scrollHeader(direction: ScrollDirection): {\r\n        maxScrollDistance: number;\r\n        distance: number;\r\n    };\r\n    /** Handles click events on the pagination arrows. */\r\n    _handlePaginatorClick(direction: ScrollDirection): void;\r\n    /**\r\n     * Moves the tab list such that the desired tab label (marked by index) is moved into view.\r\n     *\r\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\r\n     * should be called sparingly.\r\n     */\r\n    _scrollToLabel(labelIndex: number): void;\r\n    /**\r\n     * Evaluate whether the pagination controls should be displayed. If the scroll width of the\r\n     * tab list is wider than the size of the header container, then the pagination controls should\r\n     * be shown.\r\n     *\r\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\r\n     * should be called sparingly.\r\n     */\r\n    _checkPaginationEnabled(): void;\r\n    /**\r\n     * Evaluate whether the before and after controls should be enabled or disabled.\r\n     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\r\n     * before button. If the header is at the end of the list (scroll distance is equal to the\r\n     * maximum distance we can scroll), then disable the after button.\r\n     *\r\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\r\n     * should be called sparingly.\r\n     */\r\n    _checkScrollingControls(): void;\r\n    /**\r\n     * Determines what is the maximum length in pixels that can be set for the scroll distance. This\r\n     * is equal to the difference in width between the tab list container and tab header container.\r\n     *\r\n     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\r\n     * should be called sparingly.\r\n     */\r\n    _getMaxScrollDistance(): number;\r\n    /** Tells the ink-bar to align itself to the current label wrapper */\r\n    _alignInkBarToSelectedTab(): void;\r\n    /** Stops the currently-running paginator interval.  */\r\n    _stopInterval(): void;\r\n    /**\r\n     * Handles the user pressing down on one of the paginators.\r\n     * Starts scrolling the header after a certain amount of time.\r\n     * @param direction In which direction the paginator should be scrolled.\r\n     */\r\n    _handlePaginatorPress(direction: ScrollDirection, mouseEvent?: MouseEvent): void;\r\n    /**\r\n     * Scrolls the header to a given position.\r\n     * @param position Position to which to scroll.\r\n     * @returns Information on the current scroll distance and the maximum.\r\n     */\r\n    private _scrollTo;\r\n    static ngAcceptInputType_selectedIndex: NumberInput;\r\n}\r\n"]}